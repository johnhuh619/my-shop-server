# 쇼핑몰 아키텍처 명세서

## 1. 시스템의 핵심 목표

- **결제는 단 한 번만 발생**
- **과거 주문 데이터는 절대 변하지 않음**
- **재고 동시성 문제 해결**
- **느린 작업은 비동기로 분리**
- **장애가 나도 복구 가능**

---

## 2. 도메인 역할 정의

| 도메인 | 역할 한 줄 요약 |
|--------|----------------|
| User | 인증의 주체 (JWT 발급 대상) |
| Product | 현재 판매 중인 상품 정보 |
| Inventory | 실시간 재고 관리 (경쟁 자원) |
| Order | 사용자의 구매 의사 |
| OrderItem | 주문 시점 상품 스냅샷 |
| Payment | 금전 거래 (멱등성 적용) |
| Refund | 금전의 역방향 흐름 |
| Outbox | 이벤트 유실 방지용 브릿지 |

---

## 3. 핵심 설계 원칙

### 3.1. 시간 개념 분리

- **Product** = 현재
- **Order / OrderItem** = 과거
- **Payment / Refund** = 돈의 흐름

> **핵심**: 과거 데이터는 현재 상태에 영향받지 않음

### 3.2. Order와 Payment 분리

- **Order** = 의사
- **Payment** = 행위

실패/재시도/부분 처리 가능

### 3.3. 멱등성의 정확한 위치

- **JWT** → "누가 요청했는지"
- **Idempotency-Key** → "같은 요청인지"
- `(user_id, idempotency_key)` → **Payment에 UNIQUE 제약**

### 3.4. 재고는 예약(reserve)으로 관리

- 주문 시점에 재고 확보
- 결제는 재고와 분리
- 실패/만료 시 롤백

### 3.5. DB 트랜잭션은 짧게

- 재고 예약 + 주문 생성까지만
- 결제/환불은 비동기

### 3.6. 이벤트 드리븐 구조

```
Outbox → Redis Stream → Worker
```

- **DB가 Source of Truth**
- **Redis는 전달자**

---

## 4. 정상 구매 흐름

### 4.1. 전체 프로세스

1. **로그인** (JWT 발급)

2. **상품 조회** (Product)

3. **주문 생성**
   - Inventory 예약
   - Order + OrderItem 생성
   - 상태: `CREATED`

4. **결제 요청**
   - JWT + Idempotency-Key
   - Payment 생성 (상태: `REQUESTED`)

5. **비동기 결제 처리**
   - Payment → `COMPLETED`
   - Order → `PAID`

6. **배송 요청 생성**
   - 이벤트 기반

---

## 5. 취소 / 환불 흐름

### 5.1. 결제 이전

```
Order CANCEL
```
- 재고 예약 해제

### 5.2. 결제 이후

```
Refund 생성
```
- Payment 기준
- 부분 환불 가능
- 재고는 정책에 따라 복구

---

## 6. 장애 대응 전략

| 상황 | 대응 방법 |
|------|----------|
| 중복 결제 요청 | Idempotency-Key |
| Redis 장애 | Outbox 재처리 |
| Worker 중복 처리 | 상태 기반 조건부 UPDATE |
| 결제 실패 | Payment FAILED + 재시도 |
| 주문 만료 | 스케줄러로 재고 롤백 |

---

## 7. 기술 스택

- **API**: Spring Boot
- **Auth**: Spring Security + JWT
- **DB**: RDB (PostgreSQL/MySQL)
- **Async**: Redis Stream
- **Pattern**: Outbox, Event-driven

---

## 8. 아키텍처 한 문장 요약 (면접용)

> "JWT 기반 인증으로 사용자를 식별하고,
> 주문은 구매 의사로, 결제는 금전 거래로 분리했습니다.
> 주문 시점에 재고를 예약해 동시성을 보장하고,
> 결제와 환불은 멱등성과 이벤트 드리븐 구조로 처리해
> 중복 결제와 장애 상황에서도 정합성을 유지합니다."

---

## 9. 아키텍처 레벨

- ❌ CRUD 쇼핑몰
- ❌ 단순 결제 연동
- ✅ **실무형 트랜잭션 + 이벤트 기반 쇼핑몰**

---

## 부록: 주요 설계 결정 사항

### A. 왜 Order와 Payment를 분리하는가?

1. **주문은 의사 표현**, 결제는 실제 금전 거래
2. 결제 실패/재시도가 주문 자체에 영향을 주지 않음
3. 부분 결제, 다중 결제 수단 등 확장 가능

### B. 왜 OrderItem에 스냅샷을 저장하는가?

1. 주문 시점의 가격/정보는 변하지 않아야 함
2. 상품 정보가 변경되어도 과거 주문은 영향받지 않음
3. 법적 증빙 자료로 활용 가능

### C. 왜 Outbox 패턴을 사용하는가?

1. 이벤트 유실 방지 (DB 트랜잭션과 함께 저장)
2. Redis 장애 시에도 재처리 가능
3. 최종 일관성(Eventual Consistency) 보장

### D. 재고 예약 방식의 장점

1. 주문 생성 시점에 재고 경쟁 해결
2. 결제 지연/실패가 재고에 즉각 영향을 주지 않음
3. 명확한 만료 정책으로 재고 복구 가능
